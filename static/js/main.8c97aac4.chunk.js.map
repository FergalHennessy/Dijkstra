{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","algorithms/dijkstra.js","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","index.js"],"names":["Node","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","getInitialGrid","currentRow","createNode","getNewGridWithWallToggled","newGrid","slice","newNode","PathfindingVisualizer","useState","setGrid","mouseIsPressed","setMouseIsPressed","animateShortestPath","nodesInShortestPathOrder","i","setTimeout","document","getElementById","visualizeDijkstra","animateDijkstra","currentNode","unshift","getNodesInShortestPathOrder","onClick","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.8c97aac4.chunk.js","sourcesContent":["import React from \"react\";\n\nimport \"./Node.css\";\n\n// BEGIN PART 3\n\nconst Node = ({\n  col,\n  isFinish,\n  isStart,\n  isWall,\n  onMouseDown,\n  onMouseEnter,\n  onMouseUp,\n  row,\n}) => {\n  // YOUR CODE HERE\n  const extraClassName = isFinish\n  ? \"node-finish\"\n  : isStart\n  ? \"node-start\"\n  : isWall\n  ? \"node-wall\"\n  : \"\";\n  return <div \n  id={`node-${row}-${col}`}\n  className={`node ${extraClassName}`}\n  onMouseDown={() => onMouseDown(row, col)}\n  onMouseEnter={() => onMouseEnter(row, col)}\n  onMouseUp={() => onMouseUp()}>\n  </div>;\n};\n\n// END PART 3\n\nexport default Node;\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const {col, row} = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import React, { useState } from \"react\";\nimport Node from \"./Node/Node\";\nimport { dijkstra, getNodesInShortestPathOrder } from \"../algorithms/dijkstra\";\n\nimport \"./PathfindingVisualizer.css\";\n\nconst START_NODE_ROW = 0;\nconst START_NODE_COL = 0;\nconst FINISH_NODE_ROW = 19;\nconst FINISH_NODE_COL = 49;\n\nconst PathfindingVisualizer = () => {\n  // BEGIN PART 5\n  const [grid, setGrid] = useState(getInitialGrid());\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\n  const handleMouseDown = (row, col) => {\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setGrid(newGrid);\n    setMouseIsPressed(true);\n  };\n  const handleMouseEnter = (row, col) => {\n    if (!mouseIsPressed) return;\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setGrid(newGrid);\n  };\n  const handleMouseUp = () => {\n    setMouseIsPressed(false);\n  };\n  \n  // END PART 5\n\n  // BEGIN PART 6\n\n  const animateDijkstra = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      // YOUR CODE HERE\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, 10 * i);\n    }\n  };\n\n  const animateShortestPath = (nodesInShortestPathOrder) => {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      // YOUR CODE HERE\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\";\n      }, 50 * i);\n    }\n  };\n\n  const visualizeDijkstra = () => {\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    let visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    let nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  };\n\n  return (\n    <>\n      <button onClick={() => visualizeDijkstra()}>\n        Visualize Dijkstra's Algorithm\n      </button>\n      <h1> Dijksatra's Algorithm visualized: draw blocks by clicking on the grid!</h1>\n      <p>Fergal Hennessy</p>\n      <div className=\"grid\">\n        { grid.map((row, rowIdx) => {\n          return (\n            <div key={rowIdx}>\n              {row.map((node, nodeIdx) => {\n                const { row, col, isFinish, isStart, isWall } = node;\n                return (\n                  <Node\n                    key={nodeIdx}\n                    col={col}\n                    isFinish={isFinish}\n                    isStart={isStart}\n                    isWall={isWall}\n                    mouseIsPressed={mouseIsPressed}\n                    onMouseDown={(row, col) => handleMouseDown(row, col)}\n                    onMouseEnter={(row, col) => handleMouseEnter(row, col)}\n                    onMouseUp={() => handleMouseUp()}\n                    row={row}\n                  ></Node>\n                );\n              })}\n            </div>\n          );\n        })} \n      </div>\n    </>\n  );\n};\n\n// END PART 6\n\n// BEGIN PART 4\n\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row < 20; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 50; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\n// YOUR ANSWER HERE\n//initialize a 20*50 board filled with nodes\n\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n  };\n};\n\n// YOUR ANSWER HERE\n//constructor for a new node\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice(); // Creates a shallow copy\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\n// YOUR ANSWER HERE\n//create identical board (same memory addresses) and flip the isWall property of the node at (row, col).\n\n// END PART 4\n\nexport default PathfindingVisualizer;\n","import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}