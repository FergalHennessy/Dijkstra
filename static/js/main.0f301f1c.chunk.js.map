{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","algorithms/dijkstra.js","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","index.js"],"names":["Node","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","getInitialGrid","currentRow","createNode","getNewGridWithWallToggled","newGrid","slice","newNode","PathfindingVisualizer","useState","setGrid","mouseIsPressed","setMouseIsPressed","animateShortestPath","nodesInShortestPathOrder","i","setTimeout","document","getElementById","visualizeDijkstra","animateDijkstra","currentNode","unshift","getNodesInShortestPathOrder","onClick","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","src","srcset","alt","align","class","encoding","aria-hidden","style","height","verticalAlign","marginRight","separator","stretchy","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.0f301f1c.chunk.js","sourcesContent":["import React from \"react\";\n\nimport \"./Node.css\";\n\n// BEGIN PART 3\n\nconst Node = ({\n  col,\n  isFinish,\n  isStart,\n  isWall,\n  onMouseDown,\n  onMouseEnter,\n  onMouseUp,\n  row,\n}) => {\n  // YOUR CODE HERE\n  const extraClassName = isFinish\n  ? \"node-finish\"\n  : isStart\n  ? \"node-start\"\n  : isWall\n  ? \"node-wall\"\n  : \"\";\n  return <div \n  id={`node-${row}-${col}`}\n  className={`node ${extraClassName}`}\n  onMouseDown={() => onMouseDown(row, col)}\n  onMouseEnter={() => onMouseEnter(row, col)}\n  onMouseUp={() => onMouseUp()}>\n  </div>;\n};\n\n// END PART 3\n\nexport default Node;\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const {col, row} = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import React, { useState } from \"react\";\nimport Node from \"./Node/Node\";\nimport { dijkstra, getNodesInShortestPathOrder } from \"../algorithms/dijkstra\";\n\nimport \"./PathfindingVisualizer.css\";\n\nconst START_NODE_ROW = 0;\nconst START_NODE_COL = 0;\nconst FINISH_NODE_ROW = 19;\nconst FINISH_NODE_COL = 49;\n\nconst PathfindingVisualizer = () => {\n  // BEGIN PART 5\n  const [grid, setGrid] = useState(getInitialGrid());\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\n  const handleMouseDown = (row, col) => {\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setGrid(newGrid);\n    setMouseIsPressed(true);\n  };\n  const handleMouseEnter = (row, col) => {\n    if (!mouseIsPressed) return;\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setGrid(newGrid);\n  };\n  const handleMouseUp = () => {\n    setMouseIsPressed(false);\n  };\n  \n  // END PART 5\n\n  // BEGIN PART 6\n\n  const animateDijkstra = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      // YOUR CODE HERE\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, 10 * i);\n    }\n  };\n\n  const animateShortestPath = (nodesInShortestPathOrder) => {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      // YOUR CODE HERE\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\";\n      }, 50 * i);\n    }\n  };\n\n  const visualizeDijkstra = () => {\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    let visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    let nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  };\n\n  return (\n    <>\n      \n      <h1> Dijksatra's Algorithm visualized: draw blocks by clicking/dragging on the grid!</h1>\n      <p>Fergal Hennessy</p>\n      <button onClick={() => visualizeDijkstra()}>\n        Visualize Dijkstra's Algorithm\n      </button>\n      <div className=\"grid\">\n        { grid.map((row, rowIdx) => {\n          return (\n            <div key={rowIdx}>\n              {row.map((node, nodeIdx) => {\n                const { row, col, isFinish, isStart, isWall } = node;\n                return (\n                  <Node\n                    key={nodeIdx}\n                    col={col}\n                    isFinish={isFinish}\n                    isStart={isStart}\n                    isWall={isWall}\n                    mouseIsPressed={mouseIsPressed}\n                    onMouseDown={(row, col) => handleMouseDown(row, col)}\n                    onMouseEnter={(row, col) => handleMouseEnter(row, col)}\n                    onMouseUp={() => handleMouseUp()}\n                    row={row}\n                  ></Node>\n                );\n              })}\n            </div>\n          );\n        })} \n      </div>\n      <h1>Dijkstra's Algorithm</h1>\n      <p>\n      Dijkstra’s algorithm finds a shortest path tree from a single source node, by building a set of nodes that have minimum distance from the source. \n      </p>\n      <img src=\"https://ds055uzetaobb.cloudfront.net/brioche/uploads/ydOEDFABWr-graph1.png?width=1200\" srcset=\"https://ds055uzetaobb.cloudfront.net/brioche/uploads/ydOEDFABWr-graph1.png?width=1200 1x,https://ds055uzetaobb.cloudfront.net/brioche/uploads/ydOEDFABWr-graph1.png?width=2400 2x,https://ds055uzetaobb.cloudfront.net/brioche/uploads/ydOEDFABWr-graph1.png?width=3600 3x\" alt=\"Graph  \"></img>\n      <p>The graph has the following:</p>\n      <ul align = \"left\">\n      <li>vertices, or nodes, denoted in the algorithm by <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style={{height:0.43056+'em', verticalAlign:0 +'em'}}></span><span class=\"mord mathdefault\" style={{marginRight:0.03588 +'em'}}>v</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style={{height:0.43056+'em', verticalAlign:0+'em'}}></span><span class=\"mord mathdefault\">u</span></span></span></span>;</li>\n      <li>weighted edges that connect two nodes: (<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>u</mi><mo separator=\"true\">,</mo><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">u,v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style={{height:0.625+'em', verticalAlign:-0.19444 + 'em'}}></span><span class=\"mord mathdefault\">u</span><span class=\"mpunct\">,</span><span class=\"mspace\" style={{marginRight:0.16666666666666666+'em'}}></span><span class=\"mord mathdefault\" style={{marginRight:0.03588+'em'}}>v</span></span></span></span>) denotes an edge, and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>u</mi><mo separator=\"true\">,</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(u,v)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style={{height:1+'em', verticalAlign:-0.25+'em'}}></span><span class=\"mord mathdefault\" style={{marginRight:0.02691 + 'em'}}>w</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">u</span><span class=\"mpunct\">,</span><span class=\"mspace\" style={{marginRight:0.16666666666666666+'em'}}></span><span class=\"mord mathdefault\" style={{marginRight:0.03588+'em'}}>v</span><span class=\"mclose\">)</span></span></span></span> denotes its weight. In the diagram on the right, the weight for each edge is written in gray.</li>\n      </ul>\n      <p>This is done by initalizing three values:</p>\n      <ul align = \"left\">\n      <li><em>dist</em>, an array of distances from the source node <em>s</em> to each node in the graph, initialized the following way: <em>dist(s)</em> = 0; and for all other nodes <em>v, dist(v) = ∞</em>. This is done at the beginning, as the algorith proceeds, dist is recalculated for each v and only finalized once shortest distance is found.\n      </li>\n      <li>Q, a <em>queue</em> of all nodes in the graph. At the end of the algorithm's progress, <em>Q</em> will be empty.</li>\n      <li><em>S</em>, an empty list indicating which nodes the algorithm has visited: at the end of the algorithm <em>S</em> will contain all the nodes of the graph.</li>\n      </ul>\n      <p>Algorithm proceeds as follows:</p>\n      <ul align = \"left\">\n      <li>While <em>Q</em> is not empty, pop the node <em>v</em> not already in S from <em>Q</em> with the smallest <em>dist(v)</em>. In the first run, source node <em>s</em> will be chosen because <em>dist(s)</em> is initialized to 0. In following runs, next smallest <em>dist</em> value is chosen.\n      </li>\n      <li>Add node <em>v</em> to <em>S</em> to indicate <em>v</em> has been visited</li>\n      <li>Update <em>dist</em> values of adjacent nodes of the current node <em>v</em> as follows: for each new adjacent node <em>u</em>, \n      <ol>\n        <li>if <em>dist(v) {'+'} weight(u,v) {'<'} dist(u)</em>, there is a new minimal distance found for <em>u</em>, so update <em>dist(u)</em> to the new minimal distance value;\n        </li>\n        <li>otherwise, no updates are made to <em>dist(u)</em>.</li>\n        </ol>\n      </li>\n      </ul>\n      <p>The algorithm has visited all nodes in the graph and found the smallest distance to each node. <em> dist</em> now contains the shortest path tree from source <em>s</em>.\n      </p>\n      <p>Note the weight of an edge(u, v) is taken from the value associated with (u, v) on the graph.</p>\n    </>\n  );\n};\n\n// END PART 6\n\n// BEGIN PART 4\n\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row < 20; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 50; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\n// YOUR ANSWER HERE\n//initialize a 20*50 board filled with nodes\n\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n  };\n};\n\n// YOUR ANSWER HERE\n//constructor for a new node\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice(); // Creates a shallow copy\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\n// YOUR ANSWER HERE\n//create identical board (same memory addresses) and flip the isWall property of the node at (row, col).\n\n// END PART 4\n\nexport default PathfindingVisualizer;\n","import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}